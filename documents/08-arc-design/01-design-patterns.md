<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- **Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)* -->

- [设计模式概述](#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0)
  - [七大原则](#%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99)
  - [二十三种设计模式](#%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
  - [图示](#%E5%9B%BE%E7%A4%BA)
  - [适用场景](#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)
    - [抽象工厂（Abstract Factory）](#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82abstract-factory)
    - [工厂方法（Factory Method）](#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95factory-method)
    - [单例模式（Singleton）](#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fsingleton)
    - [原型模式（Prototype）](#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fprototype)
    - [生成器/建造者（Builder）](#%E7%94%9F%E6%88%90%E5%99%A8%E5%BB%BA%E9%80%A0%E8%80%85builder)
    - [代理模式（Proxy）](#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8Fproxy)
    - [门面/外观模式（Facade）](#%E9%97%A8%E9%9D%A2%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8Ffacade)
    - [装饰器模式（Decorator）](#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8Fdecorator)
    - [享元模式（Flyweight）](#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8Fflyweight)
    - [组合模式（Composite）](#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8Fcomposite)
    - [适配器模式（Adapter Pattern）](#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8Fadapter-pattern)
    - [桥接模式（Bridge Pattern）](#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8Fbridge-pattern)
    - [模板方法模式（Template Method）](#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8Ftemplate-method)
    - [策略模式（Strategy）](#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8Fstrategy)
    - [责任链模式（Chain of Responsibility）](#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8Fchain-of-responsibility)
    - [迭代器模式（Iterator）](#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8Fiterator)
    - [命令模式（Command）](#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8Fcommand)
    - [状态模式（State）](#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8Fstate)
    - [备忘录模式（Memento）](#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8Fmemento)
    - [中介者模式（Mediator）](#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8Fmediator)
    - [解释器模式（Interpreter）](#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8Finterpreter)
    - [观察者模式（Observer）](#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8Fobserver)
    - [访问者模式（Visitor）](#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8Fvisitor)
    - [委派模式](#%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 设计模式概述

## 七大原则

| 设计原则           | 一句话归纳                                           | 目的                                       |
| ------------------ | ---------------------------------------------------- | ------------------------------------------ |
| 开闭原则(OCP)      | 对扩展开放，对修改关闭                               | 减少维护带来新的风险                       |
| 依赖倒置原则(DIP)  | 高层不应该依赖底层，尽可能的依赖抽象                 | 更利于代码结构的升级扩展                   |
| 单一职责原则(SRP)  | 一个类只干一件事                                     | 便于理解，提高代码可读性                   |
| 接口隔离原则(ISP)  | 一个接口只干一件事                                   | 功能解耦，高聚合、低耦合                   |
| 迪米特法则(LoD)    | 不该知道的不要知道                                   | 只和朋友交流，不和陌生人说话，减少代码臃肿 |
| 里氏替换原则(LSP)  | 子类重写方法的功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥                               |
| 合成复用原则(CARP) | 尽量使用组合实现代码复用，而不使用继承               | 降低代码耦合                               |

## 二十三种设计模式

| 類型   | 设计模式                              | 一句话归纳                                 | 目的                   | 生活案例             |
| ------ | ------------------------------------- | ------------------------------------------ | ---------------------- | -------------------- |
| 创建型 | **工厂模式(Factory)**                 | 产品标准化，生产更高效                     | 封装创建细节           | 实体工厂             |
|        | 工厂方法（Factory Method）            | (简单工厂模式的进化版)                     |                        |                      |
|        | **单例模式(Singleton)**               | 只有一个对象                               | 保证独一无二           | CEO                  |
|        | 原型模式(Prototype)                   | 拔一根猴毛，吹出千万个                     | 高效创建对象           | 克隆                 |
|        | _建造者模式(Builder)_                 | 高配中配与低配，想选哪配就哪配             | 开放个性配置步骤       | 选配                 |
| 结构型 | **代理模式(Proxy)**                   | 没有资源没时间，得找媒婆来帮忙             | 增强职责               | 媒婆                 |
|        | 门面模式(Facade)                      | 打开一扇门，走向全世界                     | 统一访问入口           | 前台、导诊台         |
|        | **装饰器模式(Decorator)**             | 他大舅他二舅都是他舅                       | 灵活扩展、同宗同源     | 煎饼                 |
|        | 享元模式(Flyweight)                   | 优化资源配置，减少重复浪费，开源节流       | 共享资源池             | 全国社保联网         |
|        | 组合模式(Composite)                   | 人在一起叫团伙(聚合)，心在一起叫团队(组合) | 统一整体和个体         | 组织架构树           |
|        | _适配器模式(Adapter)_                 | 适合自己的，才是最好的                     | 兼容转换               | 电源适配             |
|        | 桥接模式(Bridge)                      | 从现实连接抽象                             | 不允许用继承           | 桥                   |
| 行为型 | _模板模式(Template)_                  | 流程全部标准化，需要微调请覆盖             | 逻辑复用               | 把大象装进冰箱的步骤 |
|        | **策略模式(Strategy)**                | 条条大道通罗马，具体哪条你来定             | 把选择权交给用户       | 选择支付方式         |
|        | _责任链模式(Chain of Responsibility)_ | 审批盖章即担责                             | 解耦处理逻辑           | 踢皮球               |
|        | 迭代器模式(Iterator)                  | 流水线上坐一天，每个包裹扫一遍             | 统一对集合的访问方式   | 统一刷脸进站         |
|        | 命令模式(Command)                     | 运筹帷幄之中，决胜千里之外                 | 解耦请求和处理         | 遥控器               |
|        | 状态模式(State)                       | 状态驱动行为，行为决定状态                 | 绑定状态和行为         | 订单状态跟踪         |
|        | 备忘录模式(Memento)                   | 给我一剂“后悔药”                           | 备份                   | 草稿箱               |
|        | 中介者模式(Mediator)                  | 联系方式我给你，怎么搞定我不管             | 统一管理网状资源       | 朋友圈               |
|        | 解释器模式(Interpreter)               | 我想说“方言”                               | 实现特定语法解析       | 摩斯密码             |
|        | **观察者模式(Observer)**              | 到点就通知我                               | 解耦观察者与被观察者   | 闹钟                 |
|        | 访问者模式(Visitor)                   | 横看成岭侧成峰，远近高低各不同             | 解耦数据结构和数据操作 | KPI 考核             |
|        | ^委派模式(Delegate)                   | 这个需求很简单，怎么实现我不管             | 只对结果负责           | 授权委托书           |

注意：委派模式 是一种行为型模式。 在 Spring 中应用挺多的，但是不属于（GOF）23 种设计模式。

比较常用的有：工厂模式、单例模式、装饰器模式、策略模式、代理模式和观察者模式(发布订阅模式)等。
加粗比较常用，斜体次之。

GOF 的 23 中里面有观察者模式，没有**发布订阅模式**，但后者从观察者模式发展出来后，有更加独立明确的使用特性，也很常用。

## 图示

![design-patterns](./pictures/design-pattern.png)

## 适用场景

### 抽象工厂（Abstract Factory）

意图

- 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

适用性

- 一个系统要独立于它的产品的创建、组合和表示时。
- 一个系统要由多个产品系列中的一个来配置时。
- 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
- 当你提供一个产品类库，而只想显示它们的接口而不是实现时。

### 工厂方法（Factory Method）

意图

- 定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method 使一个类的实例化延迟到其子类。

适用性

- 当一个类不知道它所必须创建的对象的类的时候。
- 当一个类希望由它的子类来指定它所创建的对象的时候。
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

### 单例模式（Singleton）

意图

- 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

适用性

- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
- 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

### 原型模式（Prototype）

意图

- 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

适用性

- 当一个系统应该独立于它的产品创建、构成和表示时
- 当要实例化的类是在运行时刻指定时，例如，通过动态装载
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时。
  - 建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

### 生成器/建造者（Builder）

意图

- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

适用性

- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
- 当构造过程必须允许被构造的对象有不同的表示时。

### 代理模式（Proxy）

意图

- 为其他对象提供一种代理以控制对这个对象的访问。

适用性

在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 Proxy 模式。

- 远程代理（Remote Proxy）
  - 为一个对象在不同的地址空间提供局部代表。
- 虚代理（Virtual Proxy）
  - 根据需要创建开销很大的对象。
- 保护代理（Protection Proxy）
  - 控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。
- 缓冲代理（Cache Proxy）：
  - 为一个目标的操作结果开辟一个临时的空间存储，以便多个客户端共享使用。
- 智能指引（Smart Reference）
  - 取代了简单的指针，它在访问对象时执行一些附加操作。

它的典型用途包括：

- 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它。
- 当第一次引用一个持久对象时，将它装入内存。
- 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。

### 门面/外观模式（Facade）

意图

- 为子系统中的一组接口提供一个一致的界面， Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

适用性

- 当你要为一个复杂子系统提供一个简单接口时。
  - 子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。
  - 这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。
  - Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 facade 层。
- 客户程序与抽象类的实现部分之间存在着很大的依赖性。
  - 引入 facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。
- 当你需要构建一个层次结构的子系统时，使用 facade 模式定义子系统中每层的入口点。
  - 如果子系统之间是相互依赖的，你可以让它们仅通过 facade 进行通讯，从而简化了它们之间的依赖关系。

### 装饰器模式（Decorator）

意图

- 动态地给一个对象添加一些额外的职责。
- 就增加功能来说，Decorator 模式相比生成子类更为灵活。

适用性

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 处理那些可以撤消的职责。
- 当不能采用生成子类的方法进行扩充时。
- 情况一：可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。
- 情况二：可能是因为类定义被隐藏，或类定义不能用于生成子类。

### 享元模式（Flyweight）

意图

- 运用共享技术有效地支持大量细粒度的对象。

适用性

Flyweight 模式的有效性很大程度上取决于如何使用它以及在何处使用它。

- 一个应用程序使用了大量的对象。
- 完全由于使用大量的对象，造成很大的存储开销。
- 对象的大多数状态都可变为外部状态。
- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
- 应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。

### 组合模式（Composite）

意图

- 将对象组合成树形结构以表示“部分-整体”的层次结构。
- Composite 使得用户对单个对象和组合对象的使用具有一致性。

适用性

- 你想表示对象的部分-整体层次结构。
- 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

### 适配器模式（Adapter Pattern）

意图

- 将一个类的接口转换成客户希望的另外一个接口。
- Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

适用性

- 你想使用一个已经存在的类，而它的接口不符合你的需求。
- 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。
- （仅适用于对象 Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。

### 桥接模式（Bridge Pattern）

意图

- 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

适用性

- 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。
- 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时 Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
- 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。
- （C++）你想对客户完全隐藏抽象的实现部分。在 C++中，类的表示在类接口中是可见的。
- 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点

### 模板方法模式（Template Method）

意图

- 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
- Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

适用性

- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
  - 首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。
  - 最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
- 控制子类扩展。模板方法只在特定点调用“hook”操作（参见效果一节），这样就只允许在这些点进行扩展。

### 策略模式（Strategy）

意图

- 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

适用性

- 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。
- 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。
- 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的 Strategy 类中以代替这些条件语句

### 责任链模式（Chain of Responsibility）

意图

- 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
- 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

适用性

- 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。
- 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
- 可处理一个请求的对象集合应被动态指定。

### 迭代器模式（Iterator）

意图

- 提供一种方法顺序访问一个聚合对象中各个元素 , 而又不需暴露该对象的内部表示。

适用性

- 访问一个聚合对象的内容而无需暴露它的内部表示。
- 支持对聚合对象的多种遍历。
- 为遍历不同的聚合结构提供一个统一的接口(即,支持多态迭代)。

### 命令模式（Command）

意图

- 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。
  适用性

- 抽象出待执行的动作以参数化某对象。
  - 可以用过程语言中的回调（callback）函数表达这种参数化机制。
  - 所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。
  - Command 模式是回调机制的一个面向对象的替代品。
- 在不同的时刻指定、排列和执行请求。
  - 一个 Command 对象可以有一个与初始请求无关的生存期。
  - 如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。
- 支持取消操作。
  - Command 的 Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。
  - Command 接口必须添加一个 Unexecute 操作，该操作取消上一次 Execute 调用的效果。
  - 执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用 Unexecute 和 Execute 来实现重数不限的“取消”和“重做”。
- 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。
  - 在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。
  - 从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用 Execute 操作重新执行它们。
- 用构建在原语操作上的高层操作构造一个系统。
  - 这样一种结构在支持事务(transaction)的信息系统中很常见。一个事务封装了对数据的一组变动。
  - Command 模式提供了对事务进行建模的方法。
  - Command 有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。

### 状态模式（State）

意图

- 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

适用性

- 一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。
- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
  - 这个状态通常用一个或多个枚举常量表示。
  - 通常,有多个操作包含这一相同的条件结构。State 模式将每一个条件分支放入一个独立的类中。
  - 这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。

### 备忘录模式（Memento）

意图

- 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

适用性

- 必须保存一个对象在某一个时刻的(部分)状态,这样以后需要时它才能恢复到先前的状态。
- 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

### 中介者模式（Mediator）

意图

- 用一个中介对象来封装一系列的对象交互。
- 中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

适用性

- 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
- 一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类。

### 解释器模式（Interpreter）

意图

- 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

适用性

- 当有一个语言需要解释执行 , 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
  - 而当存在以下情况时该模式效果最好：
    - 该文法简单
    - 效率不是一个关键问题

### 观察者模式（Observer）

意图

- 定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。

适用性

- 当一个抽象模型有两个方面,其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
- 当对一个对象的改变需要同时改变其它对象,而不知道具体有多少对象有待改变。
- 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之,你不希望这些对象是紧密耦合的。

### 访问者模式（Visitor）

意图

- 表示一个作用于某对象结构中的各元素的操作。
- Visitor 模式使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

适用性

- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。
  - Visitor 使得你可以将相关的操作集中起来定义在一个类中。
  - 当该对象结构被很多应用共享时，用 Visitor 模式让每个应用仅包含需要用到的操作。
- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。
  - 改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。
  - 如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。

### 委派模式

委派模式的基本作用是负责任务的调度和分配任务。

生活实例:
比如一个具体任务的执行，首先是经过高层领导讨论，将具体的任务委派给相关部门经理，
部门经理拿到任务通知后去委派相关的员工具体执行任务，
委派任务的角色实际并非具体执行任务，而是对任务分发，执行过程进行管理。

- 优点：对内隐藏实现, 简化调用。
- 缺点：当实际处理业务的类需要扩展时，派发命令的类也需要对应做调整，不符合开闭原则。
- 代理模式 与 委派模式的区别
  - 代理模式 注重的是**过程**， 委派模式 注重的是**结果**；
  - 策略模式 注重是可扩展（外部扩展），委派模式 注重内部的灵活和复用；
  - 委派的核心：就是分发、调度、派遣；
  - 委派模式：就是静态代理和策略模式一种特殊的组合；

---

refs:

- https://www.cnblogs.com/cdaniu/p/15530517.html
- https://pdai.tech/md/dev-spec/pattern/1_overview.html
- https://github.com/Jueee/design-patterns
- https://book.douban.com/subject/34262305/

常用的设计模式:

- https://segmentfault.com/a/1190000023963515
- https://segmentfault.com/a/1190000030850326
- https://zhuanlan.zhihu.com/p/61100871
