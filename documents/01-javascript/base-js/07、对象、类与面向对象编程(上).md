<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- **Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)* -->

- [对象(Objects)、类(Class)与面向对象编程(OOP)(上)](#%E5%AF%B9%E8%B1%A1objects%E7%B1%BBclass%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boop%E4%B8%8A)
  - [理解对象](#%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1)
    - [属性的类型](#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B)
      - [数据属性（Data Properties）](#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7data-properties)
      - [访问器属性（Accessor Properties）](#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7accessor-properties)
    - [定义多个属性](#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7)
    - [读取属性的特性](#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7)
    - [合并对象](#%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1)
    - [对象标识及相等判定](#%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86%E5%8F%8A%E7%9B%B8%E7%AD%89%E5%88%A4%E5%AE%9A)
    - [增强的对象语法](#%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95)
    - [对象解构](#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84)
  - [创建对象](#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1)
    - [工厂模式](#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F)
    - [构造函数模式](#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F)
      - [基础示意](#%E5%9F%BA%E7%A1%80%E7%A4%BA%E6%84%8F)
      - [一些说明](#%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E)
    - [原型模式](#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F)
      - [理解原型](#%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B)
      - [原型层级](#%E5%8E%9F%E5%9E%8B%E5%B1%82%E7%BA%A7)
      - [3. 原型和 in 操作符](#3-%E5%8E%9F%E5%9E%8B%E5%92%8C-in-%E6%93%8D%E4%BD%9C%E7%AC%A6)
      - [4. 属性枚举顺序](#4-%E5%B1%9E%E6%80%A7%E6%9E%9A%E4%B8%BE%E9%A1%BA%E5%BA%8F)
    - [对象迭代](#%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3)
      - [其他原型语法](#%E5%85%B6%E4%BB%96%E5%8E%9F%E5%9E%8B%E8%AF%AD%E6%B3%95)
      - [原型的动态性](#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7)
      - [原生对象原型](#%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B)
      - [原型的问题](#%E5%8E%9F%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98)
  - [对象(Object)的属性和方法小结](#%E5%AF%B9%E8%B1%A1object%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93)
  - [小结](#%E5%B0%8F%E7%BB%93)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 对象(Objects)、类(Class)与面向对象编程(OOP)(上)

本章内容

- 理解对象
- 理解对象创建过程
- 理解继承
- 理解类

本节先讲解上半段：对象部分。

**ECMA-262 将对象定义为一组属性的无序集合。**

- 一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为方法。

严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。

正因为如此（以及其他还未讨论的原因），可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。

## 理解对象

对象可以通过 Object() 构造函数或者使用 对象字面量 的方式创建。

```js
// Object() 构造函数创建对象
let person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";
person.sayName = function () {
  console.log(this.name);
};

// 对象字面量创建对象
let person2 = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name);
  },
};
```

### 属性的类型

**ECMA-262 使用一些内部特性来描述属性的特征。**
这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。
为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 [[Enumerable]] 。

属性分两种：数据属性和访问器属性。

#### 数据属性（Data Properties）

数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。

数据属性有 4 个描述其行为的特性：

- `[[Configurable]]`
  - 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。
  - 默认情况下，所有直接定义在对象上的属性的这个特 性都是 true 。
- `[[Enumerable]]`
  - 表示属性是否可以通过 for-in 循环返回。
    默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
- `[[Writable]]`
  - 表示属性的值是否可以被修改。
  - 默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
- `[[Value]]`
  - 包含属性实际的值。那个读取和写入属性值的位置。
  - 这个特性的默认值为 undefined 。

将属性显式添加到对象之后， [[Configurable]] 、 [[Enumerable]] 和[[Writable]] 都会被设置为 true ，而 [[Value]] 特性会被设置为指定的值。

要修改属性的默认特性，就必须使用 `Object.defineProperty( obj, prop, descriptor)` 方法。

- 这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象。
- 最后一个参数，即描述符对象上的属性可以包含： configurable 、 enumerable 、 writable 和 value ，跟相关特性的名称一一对应。
- 根据要修改的特性，可以设置其中一个或多个值。
- 在调用 Object.defineProperty() 时， configurable 、 enumerable 和 writable 的值如果不指定，则都**默认为 false**。

```js
// 1 字面量创建对象实例
let person = {
  name: "Nicholas",
  age: 28,
};

// 其显示添加的值，其属性的[[Configurable]] 、 [[Enumerable]] 和[[Writable]] 都会被设置为 true ，而 [[Value]] 特性会被设置为指定的值
console.log(Object.getOwnPropertyDescriptor(person, "name"));
/*输出：
{
  value: 'Nicholas',
  writable: true,
  enumerable: true,
  configurable: true
}
*/

// 2 通过Object.definePropert()修改该值并设定不可修改
Object.defineProperty(person, "name", {
  writable: false,
  value: "david",
});
console.log(person.name); // david
person.name = "Greg";
console.log(person.name); // david

// 不是不可修改的值可以修改
console.log(person.age); // 28
person.age = 18;
console.log(person.age); // 18

// 3 创建不可配置的属性
/**
 * 注意：
 * 1 创建不可配置的属性，意味着这个属性不能从对象上删除。
 * 2 一个属性被定义为不可配置之后，就不能再变回可配置的了。
 */
Object.defineProperty(person, "sex", {
  configurable: false,
  value: "male",
});
console.log(person.sex); // male
delete person.sex;
console.log(person.sex); // male

Object.defineProperty(person, "sex", {
  configurable: true,
}); // 报错：TypeError: Cannot redefine property: sex ……
```

#### 访问器属性（Accessor Properties）

访问器属性不包含数据值，它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。
在读取访问器属性时，会调用 getter 函数，在写入访问器属性时，又会调用 setter 函数并传入新值。

访问器属性有如下 4 个特性：

- `[[Configurable]]`
  - 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。
  - 默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
- `[[Enumerable]]`
  - 表示属性是否可以通过 for-in 循环返回。
  - 默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
- `[[Get]]`
  - 获取函数，在读取属性时调用。
  - 默认值为 undefined 。
- `[[Set]]`
  - 设置函数，在写入属性时调用。
  - 默认值为 undefined 。

访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。

**访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。**

```js
// 定义一个对象，包含伪私有成员 year_和公共成员 edition 两个默认属性。
let book = {
  year_: 2017,
  edition: 1,
};

// 属性 year 被定义为一个访问器属性，
// 其中`获取函数`简单地返回 year_ 的值，而`设置函数`会做一些计算以决定正确的版本（edition）
Object.defineProperty(book, "year", {
  get() {
    return this.year_;
  },
  set(newValue) {
    if (newValue > 2017) {
      this.year_ = newValue;
      this.edition += newValue - 2017;
    }
  },
});
console.log(book.year); // 2017

book.year = 2018;
console.log(book.year); // 2018
console.log(book.edition); // 2
```

### 定义多个属性

ECMAScript 提供了 Object.defineProperties() 方法。

- 这个方法可以通过多个描述符一次性定义多个属性。
- 它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。

示例见下一节。

### 读取属性的特性

使用 `Object.getOwnPropertyDescriptor()` 方法可以取得指定属性的属性描述符。

- 这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。
- 返回值是一个对象，
  - 对于访问器属性包含 configurable 、 enumerable 、 get 和 set 属性，
  - 对于数据属性包含 configurable 、 enumerable 、 writable 和 value 属性。

ECMAScript 2017 新增了 `Object.getOwnPropertyDescriptors()` 静态方法。

- 这个方法实际上会在每个自有属性上调用 `Object.getOwnPropertyDescriptor()` 并在一个新对象中返回它们。

接续上一个示例：

```js
// 定义多个属性
// 一次性定义了两个数据属性 year_ 和 edition ，还有一个访问器属性 year 。
let book = {};
Object.defineProperties(book, {
  year_: {
    value: 2017,
  },

  edition: {
    value: 1,
  },

  year: {
    get() {
      return this.year_;
    },
    set(newValue) {
      if (newValue > 2017) {
        this.year_ = newValue;
        this.edition += newValue - 2017;
      }
    },
  },
});

// 取得指定属性的属性描述符。
let descriptor = Object.getOwnPropertyDescriptor(book, "year_");
console.log(descriptor.value); // 2017
console.log(descriptor.configurable); // false
console.log(typeof descriptor.get); // "undefined"

let descriptor2 = Object.getOwnPropertyDescriptor(book, "year");
console.log(descriptor2.value); // undefined
console.log(descriptor2.enumerable); // false
console.log(typeof descriptor2.get); // "function"

console.log(Object.getOwnPropertyDescriptors(book));
/* 输出：
{
  year_: {
    value: 2017,
    writable: false,
    enumerable: false,
    configurable: false
  },
  edition: { value: 1, writable: false, enumerable: false, configurable: false },
  year: {
    get: [Function: get],
    set: [Function: set],
    enumerable: false,
    configurable: false
  }
}
*/
```

### 合并对象

1. ECMAScript 6 专门为合并对象提供了 `Object.assign()` 方法。

- 这个方法接收一个目标对象和一个或多个源对象作为参数，
- 然后将每个源对象中可枚举和自有属性复制到目标对象。String 类型和 Symbol 类型的属性都会被复制。

  - 可枚举属性（ `Object.propertyIsEnumerable()` 返回 true ）
  - 自有属性（ `Object.hasOwnProperty()` 返回 true ）

- 对每个符合条件的属性，这个方法会使用源对象上的 `[[Get]]` 取得属性的值，然后使用目标对象上的 `[[Set]]` 设置属性的值。

2. Object.assign() 实际上对每个源对象执行的是**浅复制**。

- 如果多个源对象都有相同的属性，则使用最后一个复制的值。
- 此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。
- 换句话说，不能在两个对象间转移获取函数和设置函数。

3. 如果赋值期间出错，则操作会中止并退出，同时抛出错误。

- Object.assign() 没有“回滚”之前赋值的概念，因此它是**一个尽力而为、可能只会完成部分复制的方法**。

```js
/**
 * 合并对象
 */
let dest, src, result;

/** 1 简单复制 */
dest = {};
src = { id: "src" };

result = Object.assign(dest, src);

// Object.assign 修改目标对象
// 也会返回修改后的目标对象
console.log(dest === result); // true
console.log(dest !== src); // true
console.log(result); // { id: src }
console.log(dest); // { id: src }

/** 2 多个源对象 */
dest = {};
result = Object.assign(dest, { a: "foo" }, { b: "bar" });
console.log(result); // { a: foo, b: bar }

/** 3 获取函数与设置函数 */
dest = {
  set a(val) {
    console.log(`Invoked dest setter with param ${val}`);
  },
};
src = {
  get a() {
    console.log("Invoked src getter");
    return "foo";
  },
};

Object.assign(dest, src);
// 调用 src 的获取方法
// 调用 dest 的设置方法并传入参数"foo"
// 因为这里的设置函数不执行赋值操作
// 所以实际上并没有把值转移过来
console.log(dest);
/*输出：
Invoked src getter
Invoked dest setter with param foo
{ a: [Setter] }
*/

/** 4 覆盖属性 */
dest = { id: "dest" };

result = Object.assign(
  dest,
  { id: "src1", a: "foo" },
  { id: "src2", b: "bar" }
);

// Object.assign 会覆盖重复的属性
console.log(result); // { id: src2, a: foo, b: bar }

// 可以通过目标对象上的设置函数观察到覆盖的过程：
dest = {
  set id(x) {
    console.log(x);
  },
};

Object.assign(dest, { id: "first" }, { id: "second" }, { id: "third" });
// first
// second
// third

/** 5 对象引用 */
dest = {};
src = { a: {} };

Object.assign(dest, src);

// 浅复制意味着只会复制对象的引用
console.log(dest); // { a :{} }
console.log(dest.a === src.a); // true

/** 6 错误处理 */
dest = {};
src = {
  a: "foo",
  get b() {
    // Object.assign()在调用这个获取函数时会抛出错误
    throw new Error();
  },
  c: "bar",
};

try {
  Object.assign(dest, src);
} catch (e) {
  console.log(e); // Error  at Object.get b [as b] .....
}

// Object.assign()没办法回滚已经完成的修改
// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：
console.log(dest); // { a: foo }
```

### 对象标识及相等判定

ECMAScript 6 规范新增了 `Object.is()` ，这个方法与 === 很像，但同时也考虑到了边界情形。这个方法必须接收两个参数。

```js
console.log(Object.is(true, 1)); // false
console.log(Object.is({}, {})); // false
console.log(Object.is("2", 2)); // false

// 正确的 0、-0、+0 相等/不等判定
console.log(Object.is(+0, -0)); // false
console.log(Object.is(+0, 0)); // true
console.log(Object.is(-0, 0)); // false

// 正确的 NaN 相等判定
console.log(Object.is(NaN, NaN)); // true
// 要检查超过两个值，递归地利用相等性传递即可：
function recursivelyCheckEqual(x, ...rest) {
  return (
    Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest))
  );
}
console.log(recursivelyCheckEqual(0, -0, +0)); // false
```

### 增强的对象语法

ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。

这些特性都没有改变现有引擎的行为，但极大地提升了处理对象的方便程度。

1. 属性值简写

简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError 。

```js
let name = "Matt";
let person = { name };
```

2. 可计算属性

中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值。

```js
// 可计算属性
const nameKey = "name";
const ageKey = "age";
const jobKey = "job";
let uniqueToken = 0;

function getUniqueKey(key) {
  return `${key}_${uniqueToken++}`;
}

let person = {
  [getUniqueKey(nameKey)]: "Matt",
  [getUniqueKey(ageKey)]: 27,
  [getUniqueKey(jobKey)]: "Software engineer",
};

console.log(person); // { name_0: 'Matt', age_1: 27, job_2: 'Software engineer' }
```

可计算属性表达式中抛出任何错误都会中断对象创建。

如果计算属性的表达式有副作用，那就要小心了，因为如**果表达式抛出错误，那么之前完成的计算是不能回滚的**。

3. 简写方法名

在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式。新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名。

简写方法名对获取函数和设置函数也是适用的。

简写方法名与可计算属性键相互兼容。

```js
const methodKey = "sayAge";

let person = {
  // 简写方法名
  sayHi() {
    console.log(`Hello world`);
  },
  // 简写方法名对获取函数和设置函数也是适用
  name_: "",
  get name() {
    return this.name_;
  },
  set name(name) {
    this.name_ = name;
  },
  sayName() {
    console.log(`My name is ${this.name_}`);
  },
  // 简写方法名与可计算属性键相互兼容
  [methodKey](age) {
    console.log(`My age is ${age}`);
  },
};

person.sayHi(); // Hello world
person.name = "Matt";
person.sayName(); // My name is Matt
person.sayAge(28); // My age is 28
```

### 对象解构

对象解构就是使用与对象匹配的结构来实现对象属性赋值。

- 使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。
  - 如果想让变量直接使用属性的名称，那么可以使用简写语法。
- **解构赋值不一定与对象的属性匹配**。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined。
- 可以在解构赋值的同时定义默认值。
- 解构在内部使用函数 ToObject() （不能在运行时环境中直接访问）把源数据结构转换为对象。
  - 这意味着**在对象解构的上下文中，原始值会被当成对象**。
  - 这也意味着（根据 ToObject() 的定义）， **null 和 undefined 不能被解构，否则会抛出错误**。
- 解构并不要求变量必须在解构表达式中声明。
  - 不过，如果是**给事先声明的变量赋值，则赋值表达式必须包含在一对括号中**。

```js
let person = {
  lname: "Matt",
  age: 27,
  address: "China",
};

let { lname, age, address: personAddress, job, sex = "male" } = person;
// 对象解构
console.log(lname); // "Matt"
console.log(age); // 27
// 自定义属性对应的变量名
console.log(personAddress); // "China"
// 引用的属性不存在，则该变量的值就是 undefined
console.log(job); // undefined
// 解构时有设默认值
console.log(sex); // "male"

// 原始值会被当成对象
let { length } = "foobar";
console.log(length); // 6
let { constructor: c } = 4;
console.log(c === Number); // true

// null和 undefined 不能被解构
// let { _ } = null;           // TypeError
// let { _ } = undefined;      // TypeError

// 是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中
let bookName, bookAuthor;
let book = {
  name: "看图识字",
  author: "张三",
};
({ name: bookName, author: bookAuthor } = book);
console.log(bookName, bookAuthor); // 看图识字 张三
```

1. 嵌套解构

- 解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性。
- 解构赋值可以使用嵌套结构，以匹配嵌套的属性。
- 在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样

```js
let person = {
  name: "Matt",
  age: 27,
  job: {
    title: "Software engineer",
  },
};
/**1 通过解构来复制对象属性 */
let personCopy = {};
({ name: personCopy.name, age: personCopy.age, job: personCopy.job } = person);

// 因为一个对象的引用被赋值给 personCopy，所以修改
// person.job 对象的属性也会影响 personCopy
person.job.title = "Hacker";
console.log(person);
// { name: 'Matt', age: 27, job: { title: 'Hacker' } }
console.log(personCopy);
// { name: 'Matt', age: 27, job: { title: 'Hacker' } }

/** 2 解构赋值可以使用嵌套结构，以匹配嵌套的属性 */
// 声明 title 变量并将 person.job.title 的值赋给它
let {
  job: { title },
} = person;
console.log(title); // Hacker

/** 3 在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样 */
let personCopy2 = {};
// foo 在源对象上是 undefined
// ({ foo: { bar: personCopy2.bar } } = person); // TypeError: Cannot read property 'bar' of undefined
// job 在目标对象上是 undefined
// ({ job: { title: personCopy2.job.title } } = person); // TypeError: Cannot set property 'title' of undefined
```

2. 部分解构

涉及多个属性的解构赋值是一个输出无关的顺序化操作。

如果一个解构表达式涉及多个赋值，**开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分**。

```js
let person = { name: "Matt", age: 27 };

let personName, personBar, personAge;
try {
  // person.foo 是 undefined，因此会抛出错误
  ({
    name: personName,
    foo: { bar: personBar },
    age: personAge,
  } = person);
} catch (e) {}

console.log(personName, personBar, personAge); // Matt, undefined, undefined
```

3. 参数上下文匹配

在函数参数列表中也可以进行解构赋值。

对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量。

```js
let person = {
  name: "Matt",
  age: 27,
};

function printPerson(foo, { name, age }, bar) {
  console.log(arguments);
  console.log(name, age);
}

printPerson("1st", person, "2nd");
// [Arguments] { '0': '1st', '1': { name: 'Matt', age: 27 }, '2': '2nd' }
// Matt 27
```

## 创建对象

虽然**使用 Object 构造函数或对象字面量**可以方便地创建对象，但这些方式也有明显不足：**创建具有同样接口的多个对象需要重复编写很多代码。**

ECMAScript 6 开始正式支持类和继承。

- ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式。
- 不过，无论从哪方面看，_ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已_。

### 工厂模式

工厂模式是一种众所周知的设计模式，用于抽象创建特定对象的过程。

```js
function createPerson(name, age, job) {
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function () {
    console.log(this.name);
  };
  return o;
}

// 可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。
let person1 = createPerson("Nicholas", 29, "Software Engineer");
let person2 = createPerson("Greg", 27, "Doctor");
```

这种工厂模式虽然可以解决创建多个类似对象的问题，但**没有解决对象标识问题（即新创建的对象是什么类型）**。

### 构造函数模式

#### 基础示意

可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function () {
    console.log(this.name);
  };
}

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");

// 两个对象都有一个 constructor 属性指向 Person。（下详）
console.log(person1.constructor == Person); // true
console.log(person2.constructor == Person); // true

// 在这个例子中， person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承自 Object。

person1.sayName(); // Nicholas
person2.sayName(); // Greg
```

与前一个工厂模式的 createPerson()函数基本一致，主要区别：

- 没有显式地创建对象。
- 属性和方法直接赋值给了 this 。
- 没有 return 。

函数名 Person 的首字母大写了。**按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。**

要创建 Person 的实例，应使用 **new 操作符**。以这种方式**调用构造函数会执行如下操作**:

- (1) 在内存中创建一个新对象。
- (2) 这个新对象内部的 `[[Prototype]]` 特性被赋值为构造函数的 prototype 属性。
- (3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。
- (4) 执行构造函数内部的代码（给新对象添加属性）。
- (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。

简单点：js new 对象的过程：

- 1、新生成了一个对象
- 2、链接到原型
- 3、绑定 this
- 4、返回新对象

new 关键字会进行如下的操作：

1. 创建一个空的简单 JavaScript 对象（即{}）；
2. 为步骤 1 新创建的对象添加属性`__proto__`，将该属性链接至构造函数的原型对象 ；
3. 将步骤 1 新创建的对象作为 this 的上下文 ；
4. 如果该函数没有返回对象，则返回 this。

constructor 本来是用于标识对象类型的。不过，一般认为 instanceof 操作符是确定对象类型更可靠的方式。
定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。

在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数：

```js
function Person() {
  this.name = "Jake";
  this.sayName = function () {
    console.log(this.name);
  };
}

let person1 = new Person();
// let person2 = new Person;
person1.sayName(); // Jake
// person2.sayName(); // Jake
```

#### 一些说明

1. 构造函数也是函数

**构造函数与普通函数唯一的区别就是调用方式不同。**

- 除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。
- **任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操作符调用的函数就是普通函数**。
- **按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头**。

**在调用一个函数而没有明确设置 this 值的情况下（即没有作为对象的方法调用，或者没有使用 call() / apply() 调用）， this 始终指向 Global 对象（在浏览器中就是 window 对象）。**

2. 构造函数的问题

构造函数的主要问题在于，**其定义的方法会在每个实例上都创建一遍。**

对前面的例子而言， person1 和 person2 都有名为 sayName() 的方法，但这两个方法不是同一个 Function 实例。ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。

**每个 Person 实例都会有自己的 Function 实例用于显示 name 属性**。  
当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function 实例的机制是一样的。  
因此**不同实例上的函数虽然同名却不相等**。

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function () {
    console.log(this.name);
  };
  // this.sayName = new Function("console.log(this.name)"); // 逻辑等价
}
let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");

console.log(person1.sayName == person2.sayName); // false
```

要解决这个问题，可以把函数定义转移到构造函数外部：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

function sayName() {
  console.log(this.name);
}

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");

person1.sayName(); // Nicholas
person2.sayName(); // Greg
console.log(person1.sayName == person2.sayName); // false
```

在构造函数内部， sayName 属性等于全局 sayName()函数。
因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2 共享了定义在全局作用域上的 sayName() 函数。

**这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。**

这个新问题可以通过原型模式来解决。

### 原型模式

- **每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。**
  - 实际上，这个对象就是通过调用构造函数创建的对象的原型。
- **使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。**
  - 原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。

```js
function Person() {}
// 使用函数表达式也可以
// let Person = function () { };

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
  console.log(this.name);
};

let person1 = new Person();
person1.sayName(); // "Nicholas"

let person2 = new Person();
person2.sayName(); // "Nicholas"

console.log(person1.sayName == person2.sayName); // true
/* 说明：
所有属性和 sayName() 方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。
但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。
与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。
因此 person1 和 person2 访问的都是相同的属性和相同的 sayName() 函数。
*/
```

#### 理解原型

无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。

- 默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。
- 对前面的例子而言， Person.prototype.constructor 指向 Person 。
  然后，因构造函数而异，可能会给原型对象添加其他属性和方法。

在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object 。

- 每次调用构造函数创建一个新实例，这个实例的内部 `[[Prototype]]` 指针就会被赋值为构造函数的原型对象。
- 脚本中没有访问这个 `[[Prototype]]` 特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露`__proto__`属性，通过这个属性可以访问对象的原型。
  在其他实现中，这个特性完全被隐藏了。
- 关键在于理解这一点：**实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。**

**看以下代码更加明确**：

```js
/**
 * 1 构造函数可以是函数表达式 ,也可以是函数声明，因此以下两种形式都可以：
 *   function Person() {}
 *   let Person = function() {}
 */
function Person() {}
Person.prototype.name = "David";

/**
 * 2 声明之后，构造函数就有了一个与之关联的原型对象：
 */
console.log(typeof Person.prototype); // object
console.log(Person.prototype); // Person { name: 'David' } // 注意node中和浏览器console的显示差别
// {name: 'David', constructor: ƒ}
// name: "David"
// constructor: ƒ Person()
// [[Prototype]]: Object

/**
 * 3 构造函数有一个 prototype 属性引用其原型对象，而这个原型对象也有一个 constructor 属性，引用这个构造函数。
 * 换句话说，两者循环引用：
 */
console.log(Person.prototype.constructor === Person); // true

/**
 * 4 正常的原型链都会终止于 Object 的原型对象 。Object 原型的原型是 null 。
 */
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Person.prototype.__proto__.constructor === Object); // true
console.log(Person.prototype.__proto__.__proto__ === null); // true

console.log(Person.prototype.__proto__); // {} //注意node中和浏览器console的显示差别
// {
//     constructor: ƒ,
//     __defineGetter__: ƒ,
//     __defineSetter__: ƒ,
//     hasOwnProperty: ƒ,
//     __lookupGetter__: ƒ,
//     …
// }

let person1 = new Person(),
  person2 = new Person();

/**
 * 5 构造函数、原型对象和实例 ，是 3 个完全不同的对象：
 */
console.log(person1 !== Person); // true
console.log(person1 !== Person.prototype); // true
console.log(Person.prototype !== Person); // true

/**
 * 6 实例通过__proto__链接到原型对象， 它实际上指向隐藏特性[[Prototype]]
 * 构造函数通过 prototype 属性链接到原型对象
 * 【实例与构造函数没有直接联系，与原型对象有直接联系。】
 */
console.log(person1.__proto__ === Person.prototype); // true
console.log(person1.__proto__.constructor === Person); // true

console.log(Person.prototype.constructor === Person); // true

/**
 * 7 同一个构造函数创建的两个实例 ，共享同一个原型对象。
 */
console.log(person1.__proto__ === person2.__proto__); // true

/**
 * 8 instanceof 检查实例的原型链中，是否包含指定构造函数的原型：
 */
console.log(person1 instanceof Person); // true
console.log(person1 instanceof Object); // true
console.log(Person.prototype instanceof Object); // true

/**
 * 9 检查构造函数、原型对象、实例之间关系
 * 使用原型对象的 isPrototypeOf() 方法确定两个对象之间的这种关系。
 */
console.log(Person.prototype.isPrototypeOf(person1)); // true
console.log(Person.prototype.isPrototypeOf(person2)); // true

// Object.getPrototypeOf() ，返回参数的内部特性[[Prototype]] 的值。
console.log(Object.getPrototypeOf(person1) == Person.prototype); // true
console.log(Object.getPrototypeOf(person1).name); // David
```

```js
/*
当谈到继承时，JavaScript 只有一种结构：对象。
每个实例对象（object）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype）。
该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为 null。
根据定义，null 没有原型，并作为这个原型链中的最后一个环节。

几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
*/

function Person() {}
let person1 = new Person();

/**
 * 构造函数、原型对象和实例 是 3 个完全不同的对象：
 * person1: 实例
 * Person: 构造函数
 * Person.prototype: 原型对象
 */
// 简单记住几个重要的等式
console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true

console.log(Person.__proto__ === Function.prototype); // true
console.log(Person.prototype.constructor === Person); // true
```

`Object.setPrototypeOf()` 可能会严重影响代码性能。可以通过 Object.create() 来创建一个新对象，同时为其指定原型。

```js
let biped = {
  numLegs: 2,
};
let person = Object.create(biped);
person.name = "Matt";

console.log(person.name); // Matt
console.log(person.numLegs); // 2
console.log(Object.getPrototypeOf(person) === biped); // true
```

#### 原型层级

在通过对象访问属性时，会按照这个属性的名称开始搜索。

- 搜索开始于对象实例本身。

  - 如果在这个实例上发现了给定的名称，则返回该名称对应的值。
  - 如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。

```txt
因此，在调用 person1.sayName() 时，会发生两步搜索。
- 首先，JavaScript 引擎会问：“ person1 实例有 sayName 属性吗？”答案是没有。
- 然后，继续搜索并问：“ person1 的原型有 sayName 属性吗？”答案是有。
- 于是就返回了保存在原型上的这个函数。
在调用 person2.sayName() 时，会发生同样的搜索过程，而且也会返回相同的结果。

这就是原型用于在多个对象实例间共享属性和方法的原理。
```

- 注意：**前面提到的 constructor 属性只存在于原型对象，因此通过实例对象也是可以访问到的。**

虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。

- **如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。**
- 不过，使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。

`hasOwnProperty()` 方法用于确定某个属性是在实例上还是在原型对象上。

- 这个方法是继承自 Object 的，会在属性存在于调用它的对象实例上时返回 true 。

```js
/**
 * 给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，
 * 虽然不会修改它，但会屏蔽对它的访问。
 */
function Person() {}

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
  console.log(this.name);
};

let person1 = new Person();
let person2 = new Person();

console.log(person1.hasOwnProperty("name")); // false
console.log("name" in person1); // true

person1.name = "Greg";
console.log(person1.name); // "Greg"，来自实例
console.log(person1.hasOwnProperty("name")); // true
console.log("name" in person1); // true

console.log(person2.name); // "Nicholas"，来自原型
console.log(person2.hasOwnProperty("name")); // false
console.log("name" in person2); // true
/*
console.log() 访问 person1.name 时，会先在实例上搜索个属性。因为这个属性在实例上存在，所以就不会再搜索原型对象了。
而在访问 person2.name 时，并没有在实例上找到这个属性，所以会继续搜索原型对象并使用定义在原型上的属性。
*/

delete person1.name;
console.log(person1.name); // "Nicholas"，来自原型
console.log(person1.hasOwnProperty("name")); // false
console.log("name" in person1); // true
```

#### 3. 原型和 in 操作符

有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。

- 在单独使用时， in 操作符会在可以通过对象访问指定属性时返回 true ，无论该属性是在实例上还是在原型上。(见上一节的最后示例)
- 在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。
  - 遮蔽原型中不可枚举(`[[Enumerable]]` 特性被设置为 false )属性的实例属性也会在 for-in 循环中返回，
  - 因为默认情况下开发者定义的属性都是可枚举的。

只要通过对象可以访问， in 操作符就返回 true ，而 hasOwnProperty() 只有属性存在于实例上时才返回 true 。

因此，**只要 in 操作符返回 true 且 hasOwnProperty() 返回 false，就说明该属性是一个原型属性。**

```js
// 如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用 hasOwnProperty() 和 in 操作符：
function hasPrototypeProperty(object, name) {
  return !object.hasOwnProperty(name) && name in object;
}

function Person() {}

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
  console.log(this.name);
};

let person = new Person();
console.log(person); // Person {} // 注意，实例没属性
console.log(hasPrototypeProperty(person, "name")); // true

person.name = "Greg";
console.log(hasPrototypeProperty(person, "name")); // false
/*
在这里， name 属性首先只存在于原型上，所以 hasPrototypeProperty() 返回 true 。
而在实例上重写这个属性后，实例上也有了这个属性，因此 hasPrototypeProperty() 返回 false 。
即便此时原型对象还有 name 属性，但因为实例上的属性遮蔽了它，所以不会用到。 
*/
```

- 要获得对象上**所有可枚举**的实例属性，可以使用 `Object.keys()` 方法。
  - 这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。
- 列出**所有实例属性**，无论是否可以枚举，都可以使用 `Object.getOwnPropertyNames()`
- 列出**以符号为键的属性**， 使用`Object.getOwnPropertySymbols()` 方法

```js
function Person() {}

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
  console.log(this.name);
};

// 原型上所有可枚举的实例属性
console.log(Object.keys(Person.prototype)); // [ 'name', 'age', 'job', 'sayName' ]

let p1 = new Person();
p1.name = "Rob";
p1.age = 31;

// 实例中所有可枚举的实例属性
console.log(Object.keys(p1)); // [ 'name', 'age' ]

// 想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()
console.log(Object.getOwnPropertyNames(Person.prototype)); // [ 'constructor', 'name', 'age', 'job', 'sayName' ] // constructor为不可枚举的属性
console.log(Object.getOwnPropertyNames(p1)); // [ 'name', 'age' ]

// 获取符号属性;
let k1 = Symbol("k1"),
  k2 = Symbol("k2");
let o = {
  [k1]: "k1",
  [k2]: "k2",
};

console.log(Object.getOwnPropertySymbols(o)); // [Symbol(k1), Symbol(k2)]
```

#### 4. 属性枚举顺序

- `for-in` 循环和 `Object.keys()`的**枚举顺序是不确定**的，取决于 JavaScript 引擎，可能因浏览器而异。
- `Object.getOwnPropertyNames()` 、 `Object.getOwnPropertySymbols()` 和 `Object.assign()`的**枚举顺序是确定性**的。
  - **先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。**
  - 在对象字面量中定义的键以它们逗号分隔的顺序插入。

```js
let k1 = Symbol("k1"),
  k2 = Symbol("k2");

let o = {
  1: 1,
  first: "first",
  [k1]: "sym2",
  0: 0,
};

o[k2] = "sym2";
o[3] = 3;
o.third = "third";
o[2] = 2;
o.second = "second";

/**
 * key的插入顺序为 1、first、k1、0、K2、3、third、2、second
 * 先升序数值：0、1、2、3
 * 再插入属性字符串和符号：first、k1、k2、third、second
 * 拼在一起：0、1、2、3、first、k1、k2、third、second
 * 可枚举属性的顺序：0、1、2、3、first、third、second
 * 符号属性的顺序：k1、k2
 */
console.log(Object.getOwnPropertyNames(o));
// [ '0', '1', '2', '3', 'first', 'third', 'second' ]

console.log(Object.getOwnPropertySymbols(o));
// [Symbol(k1), Symbol(k2)]
```

### 对象迭代

ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式

- Object.values() 和 Object.entries() 接收一个对象，返回它们内容的数组。
  - Object.values() 返回对象值的数组
  - Object.entries() 返回键/值对的数组。
- 注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制。
- 符号属性会被忽略。

#### 其他原型语法

详见示例：

```js
//  前面的例子，每次定义一个属性或方法都会把 Person.prototype 重写一遍
/*
function Person() { }

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
    console.log(this.name);
};
*/

// 为了减少代码冗余，也为了从视觉上更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法:
function Person() {}

Person.prototype = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name);
  },
};

//  Person.prototype 被设置为等于一个通过对象字面量创建的新对象。
// 最终结果是一样的，只有一个问题：这样重写之后， Person.prototype 的 constructor 属性就不指向 Person了。
// 上面的写法完全重写了默认的 prototype 对象，因此其 constructor 属性也指向了完全不同的新对象（ Object 构造函数），不再指向原来的构造函数。
console.log(Person.prototype.constructor == Object); // true
console.log(Person.prototype.constructor == Person); // false

let friend = new Person();

console.log(friend instanceof Object); // true
console.log(friend instanceof Person); // true
console.log(friend.constructor == Person); // false
console.log(friend.constructor == Object); // true

// 如果 constructor 的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值：
// 但要注意，以这种方式恢复 constructor 属性会创建一个 [[Enumerable]] 为 true 的属性。而原生 constructor 属性默认是不可枚举的
function Person2() {}

Person2.prototype = {
  constructor: Person2,
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name);
  },
};

console.log(Person2.prototype.constructor == Object); // false
console.log(Person2.prototype.constructor == Person2); // true
console.log(Object.keys(Person2.prototype)); // [ 'constructor', 'name', 'age', 'job', 'sayName' ]

// 如果为了保持constructor不可枚举的特质，如果你使用的是兼容 ECMAScript 的 JavaScript 引擎，
// 那可能会改为使用 Object.defineProperty() 方法来定义 constructor 属性：
function Person3() {}

Person3.prototype = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name);
  },
};

// 恢复 constructor 属性
Object.defineProperty(Person3.prototype, "constructor", {
  enumerable: false,
  value: Person3,
});

console.log(Person3.prototype.constructor == Object); // false
console.log(Person3.prototype.constructor == Person3); // true
console.log(Object.keys(Person3.prototype)); // [ 'name', 'age', 'job', 'sayName' ]
```

#### 原型的动态性

因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，**任何时候对原型对象所做的修改也会在实例上反映出来**。

```js
function Person() {}

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
  console.log(this.name);
};

let friend = new Person();

Person.prototype.sayHi = function () {
  console.log("hi");
};

// 虽然 friend 实例是在添加方法之前创建的，但它仍然可以访问这个方法。之所以会这样，主要原因是实例与原型之间松散的联系。
// 在调用 friend.sayHi() 时，首先会从这个实例中搜索名为 sayHi 的属性。在没有找到的情况下，运行时会继续搜索原型对象。
// 因为实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到 sayHi 属性并返回这个属性保存的函数。
friend.sayHi(); // hi
```

虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，这跟重写整个原型是两回事:

- 实例的 `[[Prototype]]` 指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。
- 重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。
- **实例只有指向原型的指针，没有指向构造函数的指针。**
- 重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。

```js
// 给原型动态添加属性和方法与重写原型的不同：
function Person() {}

let friend = new Person();

Person.prototype = {
  constructor: Person,
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name);
  },
};
// Person 的新实例是在重写原型对象之前创建的。在调用 friend.sayName() 的时候，会导致错误。
// 这是因为 firend 指向的原型还是最初的原型，而这个原型上并没有 sayName 属性。
friend.sayName(); // TypeError: friend.sayName is not a function
```

#### 原生对象原型

原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。

- 所有原生引用类型的构造函数（包括 Object 、 Array 、 String 等）都在原型上定义了实例方法。
- 通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。
- 可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。

尽管可以这么做，但并**不推荐在产品环境中修改原生对象原型**。

- 这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。
- 另外还有可能意外重写原生的方法。**推荐的做法是创建一个自定义的类，继承原生类型**。

#### 原型的问题

原型模式也不是没有问题。

- 它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。
- **原型的最主要问题源自它的共享特性**。

原型上的所有属性是在实例间共享的，这对函数来说比较合适。

- 包含原始值的属性也还好，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。
- 真正的问题来自包含引用值的属性。
- **一般来说，不同的实例应该有属于自己的属性副本。**

```js
function Person() {}

// Person.prototype 有一个名为 friends 的属性，它包含一个字符串数组。
Person.prototype = {
  constructor: Person,
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  friends: ["Shelby", "Court"],
  sayName() {
    console.log(this.name);
  },
};

// 这里创建了两个 Person 的实例。
let person1 = new Person();
let person2 = new Person();

// person1.friends 通过 push 方法向数组中添加了一个字符串。
person1.friends.push("Van");

// 由于这个friends 属性存在于 Person.prototype 而非 person1 上，
// 新加的这个字符串也会在（指向同一个数组的）person2.friends 上反映出来。
console.log(person1.friends); // "Shelby,Court,Van"
console.log(person2.friends); // "Shelby,Court,Van"
console.log(person1.friends === person2.friends); // true
```

## 对象(Object)的属性和方法小结

| 分类     | 名称                                    | 作用                                                                                           |
| -------- | --------------------------------------- | ---------------------------------------------------------------------------------------------- |
| 静态方法 | Object.assign()                         | 通过复制一个或多个对象来创建一个新的对象。                                                     |
|          | Object.create()                         | 使用指定的原型对象和属性创建一个新对象。                                                       |
|          | Object.keys()                           | 返回一个包含所有给定对象自身可枚举属性名称的数组。                                             |
|          | Object.values()                         | 返回给定对象自身可枚举值的数组。                                                               |
|          | Object.entries()                        | 返回给定对象自身可枚举属性的 [key, value] 数组。                                               |
|          | Object.defineProperty()                 | 给对象添加一个属性并指定该属性的配置。                                                         |
|          | Object.defineProperties()               | 给对象添加多个属性并分别指定它们的配置。                                                       |
|          | Object.setPrototypeOf()                 | 设置对象的原型（即内部 `[[Prototype]]` 属性）。                                                |
|          | Object.getOwnPropertyDescriptor()       | 返回对象指定的属性配置。                                                                       |
|          | Object.getOwnPropertyNames()            | 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。                                 |
|          | Object.getOwnPropertySymbols()          | 返回一个数组，它包含了指定对象自身所有的符号属性。                                             |
|          | Object.getPrototypeOf()                 | 返回指定对象的原型对象。                                                                       |
|          | Object.is()                             | 比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。                                     |
|          | Object.isExtensible()                   | 判断对象是否可扩展。                                                                           |
|          | Object.preventExtensions()              | 防止对象的任何扩展。                                                                           |
|          | Object.seal()                           | 防止其他代码删除对象的属性。                                                                   |
|          | Object.isSealed()                       | 判断对象是否已经密封。                                                                         |
|          | Object.freeze()                         | 冻结对象：其他代码不能删除或更改任何属性。                                                     |
|          | Object.isFrozen()                       | 判断对象是否已经冻结。                                                                         |
| 实例属性 | Object.prototype.constructor            | 一个引用值，指向 Object 构造函数。                                                             |
| 实例方法 | Object.prototype.hasOwnProperty()       | 返回一个布尔值，用于表示一个对象自身是否包含指定的属性，该方法并不会查找原型链上继承来的属性。 |
|          | Object.prototype.isPrototypeOf()        | 返回一个布尔值，用于表示该方法所调用的对象是否在指定对象的原型链中。                           |
|          | Object.prototype.propertyIsEnumerable() | 返回一个布尔值，用于表示内部属性 ECMAScript `[[Enumerable]]` attribute 是否被设置。            |
|          | Object.prototype.toLocaleString()       | 调用 toString()。                                                                              |
|          | Object.prototype.toString()             | 返回一个代表该对象的字符串。                                                                   |
|          | Object.prototype.valueOf()              | 返回指定对象的原始值。                                                                         |

## 小结

对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。

下面的模式适用于创建对象:

- **工厂模式**就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。
  - 这个模式在构造函数模式出现后就很少用了。
- 使用**构造函数模式**可以自定义引用类型，可以使用 new 关键字像创建内置类型实例一样创建自定义类型的实例。
  - 构造函数模式也有不足，主要是其成员无法重用，包括函数。
  - 考虑到函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享。
- **原型模式**解决了成员共享的问题，只要是添加到构造函数 prototype 上的属性和方法就可以共享。
  - 而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。
