<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- **Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)* -->

- [前端工程化](#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96)
  - [0. vue 开发风格指南](#0-vue-%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97)
  - [1. 什么是前端工程化](#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96)
  - [2. 前端工程化的内容](#2-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AE%B9)
  - [3. 组件设计原则](#3-%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)
  - [4. 组件二次封装原则(以 vue 为例)](#4-%E7%BB%84%E4%BB%B6%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%E5%8E%9F%E5%88%99%E4%BB%A5-vue-%E4%B8%BA%E4%BE%8B)
  - [5. code review](#5-code-review)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 前端工程化

## 0. vue 开发风格指南

总结[vue2 风格指南](https://v2.cn.vuejs.org/v2/style-guide/index.html)和[vue3 Style Guide](https://cn.vuejs.org/style-guide/rules-essential.html)

camelCase:驼峰命名; PascalCase:首字母全大写; kebab-case:全小写用横线连接.

**必要规则**

- **组件名为多个单词**: 组件名应该始终是多个单词的，根组件 App 以及 `<transition>`、`<component>` 之类的 Vue 内置组件除外
  - 可以避免跟现有的以及未来的 HTML 元素**相冲突**，因为所有的 HTML 元素名称都是单个单词的。
- **组件数据**: 组件的 _data 必须是一个函数_。(vue3 无此条)
- **Prop 定义**应该尽量详细。_至少需要指定其类型_。
- **为 v-for 设置键值**: 在组件上*总是必须用 key 配合 v-for*，以便维护内部组件及其子树的状态。
- **避免 v-if 和 v-for 用在一起**: *永远不要把 v-if 和 v-for 同时用在同一个元素上。*如果两者同时存在于一个节点上时:
  - vue2 中，v-for 的优先级高于 v-if。_v-if 会在每一个 v-for 循环渲染出来的项上作用，造成性能上的浪费_。
  - vue3 中，v-if 比 v-for 的优先级更高。这意味着 _v-if 的条件将无法访问到 v-for 作用域内定义的变量别名_。
- **为组件样式设置作用域必要**: 对于应用来说，顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。
  - 这条规则*只和单文件组件*有关。不一定要使用 scoped attribute。设置作用域也可以通过 [CSS Modules](https://vue-loader-v14.vuejs.org/zh-cn/features/css-modules.html)(组件库开发更倾向)。
  - **私有 property 名**: 始终*使用`$_`前缀*来表示插件、混合组件等中的*自定义私有属性*，这些属性不应该被视为公共 API。

**强烈推荐(增强可读性)**

- **组件文件**: 只要有能够拼接文件的构建系统，就把每个组件单独分成文件。
- **单文件组件文件名的大小写**: 单文件组件的文件名应该要么始终是*单词大写开头* (PascalCase)，要么始终是*横线连接* (kebab-case)。
- **基础组件名**: 应用*特定样式和约定的基础组件*(展示类的、无逻辑的或无状态的组件)_全部以一个特定的前缀开头_，比如 Base、App 或 V。
- **单例组件名**:只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性
  - 不意味着组件只可用于一个单页面，而是**每个页面**只使用一次。这些组件*永远不接受任何 prop*，因为它们是为你的应用定制的
  - 如果发现*有必要添加 prop*，那就表明这实际上是*一个可复用的组件*，*只是目前*在每个页面里只使用一次。
- **紧密耦合的组件名**: 和父组件紧密耦合的*子组件应该以父组件名作为前缀命名*。
- **组件名中的单词顺序**: 组件名应该以*高级别的*(通常是一般化描述的)_单词开头_，_以描述性的修饰词结尾_。
  - 名词-形容词-副词-动词……这样，文件排序更好看。
  - 例如，`SearchButtonRun.vue`，`SettingsCheckboxLaunchOnStartup.vue`
- **自闭合组件**: 在单文件组件、字符串模板和 JSX 中没有内容的组件应该是**自闭合的**——但在 DOM 模板里永远不要这样做。
  - 在单文件组件、字符串模板和`JSX`中`<MyComponent/>`;在`DOM`模板中:`<my-component></my-component>`
- **模板中的组件名大小写**: 在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。
  - PascalCase 相比 kebab-case 有一些优势：
    - _编辑器可以在模板里自动补全组件名_，因为 PascalCase 同样适用于 JavaScript。
    - `<MyComponent>` 视觉上比 `<my-component>` 更能够*和单个单词的 HTML 元素区别开来。*
    - 如果在模板中使用任何非 Vue 的自定义元素，PascalCase 确保了 Vue 组件在视觉上仍然是易识别的。
  - 不幸的是，由于 **HTML 是大小写不敏感**的，在 DOM 模板中必须仍使用 kebab-case。
  - 在所有的地方都使用 kebab-case 同样是可以接受的。
- **JS/JSX 中的组件名大小写**: JS/JSX 中的组件名应该始终是 PascalCase 的。
- **完整单词的组件名**: 组件名应该倾向于完整单词而不是缩写。
- **Prop 名大小写**: 在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。
- **多个 attribute 的元素**: 多个 attribute 的元素应该分多行撰写，每个 attribute 一行
- **模板中简单的表达式**: 组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。
- **简单的计算属性**: 应该把复杂计算属性分割为尽可能多的更简单的 property。更简单的计算属性:易于测试、易于阅读、更好的“拥抱变化”
- **带引号的 attribute 值**: 非空 HTML attribute 值应该始终带引号(单引号或双引号，以 JS 中未使用的为准)。
- **指令缩写**: 指令缩写(用`:`表示`v-bind:`、用`@`表示`v-on:`和用`#`表示`v-slot:`)应该**要么都用要么都不用**。

**推荐(将选择和认知成本最小化)**

- 组件/实例的选项的顺序:(编写一个组件从上往下)，也能知道从插件里添加的新 property 应该放到哪里。
  - vue2: 1 副作用 (触发组件外的影响); 2 全局感知 (要求组件以外的知识); 3 组件类型 (更改组件的类型);4 模板修改器 (改变模板的编译方式); 5 模板依赖 (模板内使用的资源); 6 组合 (向选项里合并 property); 7 接口 (组件的接口); 8 本地状态 (本地的响应式 property); 9 事件 (通过响应式事件触发的回调); 10 非响应式的 property (不依赖响应系统的实例 property); 11 渲染 (组件输出的声明式描述)。
  - el; name、parent; functional; delimiters、comments;components、directives、filters; extends、mixins; inheritAttrs、model、props/propsData; data、computed; watch、Lifecycle Events; methods; template/render、renderError。
  - vue3: name; compilerOptions; components、directives; extends、mixins、provide/inject; inheritAttrs、props、emits; setup; data、computed; watch、Lifecycle Events; methods;template/render。
- 元素 (包括组件) 的 attribute 应该有统一的顺序。
  - 定义 (提供组件的选项) 列表渲染 (创建多个变化的相同元素) 条件渲染 (元素是否渲染/显示) 渲染方式 (改变元素的渲染方式) 全局感知 (需要超越组件的知识) 唯一的 attribute (需要唯一值的 attribute) 双向绑定 (把绑定和事件结合起来) 其它 attribute (所有普通的绑定或未绑定的 attribute) 事件 (组件事件监听器) 内容 (覆写元素的内容)
  - is、v-for、v-if、v-else-if、v-else、v-show、v-cloak、v-pre、v-once、id、ref、key、v-model、v-on、v-html、v-text
- 在多个 property 之间添加空行可以让其变得容易阅读。
- 单文件组件应该总是让`<script>`、`<template>`和`<style>`标签的顺序保持一致。`<style>`要放在最后，因为另外两个至少要有一个。

**谨慎使用(有潜在危险的模式)**

- 没有在 `v-if/v-else-if/v-else` 中使用 key。(v3 版没说)
- 元素选择器应该避免在 scoped 中出现。在 scoped 样式中，类选择器比元素选择器更好，因为*大量使用元素选择器是很慢的*。
- 应该优先通过 prop 和事件进行父子组件之间的通信，而不是 `this.$parent` 或`变更 prop`。
- 应该优先通过 Vuex 管理全局状态，而不是通过` this.$root` 或一个全局事件总线。(v3 版没说)

## 1. 什么是前端工程化

**前端工程化**是指围绕代码处理的一系列工具链，他们把代码当作字符串处理，并不关心代码的内容，包括编译构建、静态分析、格式化、CI/CD 等等。  
也可以认为*一切能提升前端开发效率、提高前端应用质量的方法和工具都是前端工程化*。

**工程化的意义**: _提升开发效率、提升产品质量、降低开发难度、降低企业成本_。

**主要目标**: 解放生产力、提高生产效率。_通过制定一系列的规范，借助工具和框架解决前端开发以及前后端协作过程中的痛点和难度问题。_

**实现前端工程化的基础**: 前后端分离。_明确前后端开发的分工_，是实现前后端分离的第一步，也是后面前端各种优化方案的基础。

**典型的前端工作流**: 分为 5 个步骤: 开发、测试、构建、部署、监控

**前端主要内容**:静态资源和动态资源的处理;js 实现前端业务逻辑;html 模板文件的产出;web 服务中间层(nodejs);前端单元测试;前端项目部署.等

**解决的问题**主要有 6 个部分:

- 传统语言或语法的弊端; 无法使用模块化/组件化; 重复的机械式工作; 代码风格统一、质量保证; 依赖后端服务接口支持; 整体依赖后端项目
- ES6+语法、TypeScript、Sass; ES Modules、Components; Build、Publish; git、ESLint; Mock; DevServer

## 2. 前端工程化的内容

**内容概述**(加粗部分表示后续有少量补充)

**开发**: **框架选型**、前后端分离、**模块化**、**组件化**、脚手架、组件库、本地开发服务器、mock 服务、微前端

**构建**: 依赖打包、文件压缩、代码分割、增量更新与缓存、资源定位、图标合并、ECMAScript 与 Babel、CSS 预编译与 PostCSS、持续构建和集成、类库打包、构建优化

**部署**: 持续部署、部署流程设计、静态资源部署策略、**nginx 反向代理**、SPA 路由配置、**跨域**、https 证书、http2 配置、灰度发布

**性能**: **缓存策略**、缓存复用、CDN 内容分发网络、按需加载、同步异步加载、请求合并、**首屏渲染速度**、http2 服务器推送、**日志性能监控**、**预加载**、性能测试

**规范化**: 目录结构规范、编码规范、技术栈规范、前后端接口规范、**commit 消息规范**、git 分支管理规范、**code review 规范**、设计规范、图标规范、文档规范、版本规范、开发流程规范、发布工作流规范

**典型的前端工作流对应的工程化内容:**

**开发阶段**: 开发阶段的首要任务是创建样板项目（一并选择前端框架、类库），接着开始修改-验证的主循环

- 脚手架：创建前端应用的目录结构，并生成样板代码
- 公共库：维护着可复用的 UI 组件、工具模块等公共资源
- 包管理器：引入第三方库/组件，并跟踪管理这些依赖项
- 编辑器：提供语法高亮、智能提示、引用跳转等功能，提升开发体验
- 构建工具：提供语法校验、编译、打包、DevServer 等功能，简化工作流
- 调试套件：提供预览、DevTools、Mock、性能分析诊断等调试功能，加速修改-验证的主循环

**测试阶段**: 开发完成，进入测试阶段，先要对整体功能进行充分自测，再移交专业的测试人员验证

- 单元测试框架：提供针对组件、逻辑的测试支持
- 静态扫描工具：从代码质量、构建产物质量、最佳实践/开发规约等多个维度做静态检查
- 自动化测试工具：针对 UI 效果和业务流程，提供测试支持
- 性能测试工具：监测并统计出相对准确的性能数据

**构建阶段**: 不同于开发阶段，在构建阶段要做更多的极限优化和流程联动

- 打包脚本：在语法校验、编译、打包的基础上，进行合并、压缩、代码拆分、图片处理、SSR 等极限优化
- 构建服务：支持多任务并行打包、通知

**部署阶段**: 最后将经过充分测试的前端应用程序部署到生产环境

- 发布平台：将前端资源上传至 CDN 或 SSR 渲染服务，或者以离线包的形式集成到移动客户端
- 迭代管理平台：提供 CI/CD 支持

**监控阶段**: 前端应用程序上线之后，还需要持续关注线上的实际效果和异常情况

- 埋点平台：统计、分析业务数据，跟踪性能指标(埋点可调用浏览器的 [Performance API](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance))
- 监控平台：观察线上的异常信息，包括报错、白屏、流量异常等

**实现前端工程化还需要熟练掌握下面几个方面**(从项目开发的整体环节来说)：

**（1）使用 Webpack 实现项目构建**

构建，简单来说就是编译，前端开发的所有文件最终归属是要交给浏览器去解析、渲染，并将页面呈现给用户，构建就是将前端开发中的所有源代码转化为宿主浏览器可以执行的代码。

前端的构建还应该考虑到 Web 应用的性能优化。这些优化主要是为了减少 HTTP 请求，提升用户体验，包括：

- 1 依赖打包，将同步依赖的文件打包在一起，减少 HTTP 请求数量；
- 2 资源嵌入，例如将小于 10kb 的图片编译为 base64 格式嵌入文档，减少 HTTP 请求；
- 3 文件压缩，减少文件体积，缩短请求时间；4 为文件加入 hash 指纹，以应对浏览器缓存策略；
- 5 将开发环境下的域名与静态资源文件路径修改为生产环境下的域名和路径；6 文件名称的改变；……

**（2）使用 Babel 完成 JavaScript 编译**

Babel 的作用简单来说，就是将浏览器未实现的 ECMAScript 规范语法转化为可运行的低版本语法，例如将 ES6 的 class 转化为 ES5 的 prototype 实现。

**（3）CSS 预编译**

CSS 预编译器的工作原理是提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源码转化为 CSS 语法。

**（4）模块化开发**

使用模块化开发，可以解决下面几个问题: 避免命名冲突；便于依赖管理；利于性能优化；提高可维护性；提高代码可复用性；

ES6 Module 是语言层面的规范，与应用场景无关，所以一个不涉及运行环境 API 调用的模块可以在任何场景下运行。但是目前浏览器还没有完全支持这种规范，所以，要实现 ES6 Module 规范的话，还需要使用构建工具进行编译。

**（5）组件化开发**

- **模块化是文件层面上对代码和资源的拆分，组件化是设计层面上对 UI 的拆分。**
- 从 UI 中拆分出来的一个结构单元，成为 UI 组件，一个 UI 组件单元包含了 HTML 模板、CSS 样式、JS 逻辑。
- 在页面的设计过程中，页面上的每一个元素都是组件，页面也是一个组件，只不过页面是一个大型组件，然后这个大型组件又由多个中小型组件拼装而成。
- 中型组件还可以再拆分成小型组件，小型组件再拆分成 DOM 元素，DOM 元素也属于浏览器自身的组件，是组件的基本单元。
- 这种组件化开发就是前端开发的“分治思想”。

**（6）开发环境的本地服务器与 Mock 服务**

在前端工程化开发中，通过构建工具可以将代码进行编译，然后在浏览器中进行调试，但是在开发过程中源码的每次修改都需要执行一次构建，构建完成后才能在浏览器里运行，这对前端工程师来说无疑就是一种灾难。  
要完美的解决这个问题，可以使用本地服务器与构建工具结合，对源码进行监听并在修改之后触发动态构建，使用自动化构建的方式代替人工。这种动态构建是使用本地服务器解决开发层面上的问题。

Mock 服务解决的是前后端协作开发的问题，前后端开发人员提前约定好规范，前端工程师通过本地服务器提供的 Mock 数据接口辅助前端逻辑的编写和功能模块的开发。  
如果项目中需要服务器端渲染（SSR），本地服务器还需要具备解析 HTML 模板的能力，同时 Mock 服务提供 SSR 所需的初始化数据。

前端工程师可以使用本地服务器提供的 Mock 数据接口，在后端人员开发的同时，进行前端逻辑的并行开发，等到后端真实接口开发完成后，将前端请求的地址从 Mock 服务迁移到服务器的生产环境即可。

**（7）规范化约束**

开发人员在设计项目的整体架构时，为了考虑到项目的可扩展性、可维护性、高内聚性等因素，会对代码进行封装，使用配置化操作，为项目开发带来便利，这必然要求业务代码编程范式遵循既定的约束。  
这种约束虽然带来了开发上的便捷，但是在一定程度上制约了代码的可移植性。

例如，在项目中使用了某个构建工具来解决项目需求，但是如果有一天项目需要更换另一个构建工具时，代码中原有的构建工具的配置会成为冗余代码，而且不能保证这类配置不会对新构建工具产生冲突。  
即便是没有产生冲突，对代码的性能优化也是会带来一定负面影响的。

工程化方案作为一种服务，_应该尽量降低对项目产生的负面影响。这是制定编程范式约束规范时最重要的考虑因素_。

- 统一的开发规范 `=>` 提高代码质量，减少维护成本
- 统一的文件组织结构 `=>` 清新美观的目录结构，便于定位问题
- 统一的的模块依赖 `=>` 相同依赖直接复用，不需要每次新建项目都 copy
- 统一的工具配置 `=>` 相同配置直接复用，发布、打包、上传等工作自动化
- 统一的基础代码 `=>` 相同代码直接复用，不需要每次新建项目都 copy

**git commit 消息一般规范**

- feat: 新功能、新特性
- fix: 修改 bug
- perf: 更改代码，以提高性能
- docs: 文档修改
- style: 代码格式修改, 注意不是 css 修改（例如分号修改）
- test: 测试用例新增、修改
- build: 影响项目构建或依赖项修改

**（8）项目部署流程化**

站在前端开发的范畴来说，_项目部署是指前端开发人员将构建产出的代码包部署到测试服务器的过程，而并非是将测试完成的代码发布到生产环境的过程。_  
在部署过程中，要考虑目标服务器、路径信息是否与项目一一对应，并且可供负责部署到生产环境的开发人员进行配置，部署的操作流程应尽量简单。

考虑团队协作和安全方面的因素，最佳的方式应该是搭建一个可供严格审查、队列控制、操作简化的部署平台，并且有专人负责掌握流程进度。  
虽然这种搭建部署平台的方式在一定程度上减缓了整体的部署速度，但是加强了团队协作和安全保障。

## 3. 组件设计原则

一句话总结: **ui 组件设计看 antd/element-ui，业务组件抽逻辑，dump 组件(展示型)纯模版，smart 组件带点 state**。

**组件分类**: 一个模块下可能现有**容器组件**(layout/container)，包含多个**业务组件**；一个业务组件可能包含多个 **UI 组件**和**展示型组件**；

**组件的能力**

- 资源高内聚（组件资源内部高内聚，组件资源由自身加载控制）
- 作用域独立（内部结构密封，不与全局或其他组件产生影响）
- 自定义标签（定义组件的使用方式）
- 可相互组合（组件间组装整合）
- 接口规范化（组件接口有统一规范，或者是生命周期的管理）

**组件的内容**

- 每个组件对应一个目录，组件所需的各种资源都在这个目录下就近维护；（最具软件工程价值）
- 页面上的每个独立的可视/可交互区域视为一个组件；
- 由于组件具有独立性，可以自由组合；
- 页面是组件的容器，负责组合组件形成功能完整的界面；
- 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换

**组件的设计原则**

- **标准性**: 任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件
- **独立性**: 描述了组件的细粒度，遵循单一职责原则，保持组件的纯粹性; 属性配置等 API 对外开放，组件内部状态对外封闭，尽可能的少与业务耦合
- **复用与易用**: UI 差异，消化在组件内部（注意并不是写一堆 if/else）; 输入输出友好，易用
- 追求短小精悍
- 适用 SPOT 法则: Single Point Of Truth，就是**尽量不要重复代码**，出自《The Art of Unix Programming》
- 避免暴露组件内部实现
- 避免直接操作 DOM，避免使用 ref: 使用父组件的 state 控制子组件的状态而不是直接通过 ref 操作子组件
- 入口处检查参数的有效性，出口处检查返回的正确性
- 无环依赖原则(ADP): 如果组件之间存在循环依赖，会变成了“先有鸡还是先有蛋”的问题
- 稳定抽象原则(SAP):
  - 组件的抽象程度与其稳定程度成正比,一个稳定的组件应该是抽象的（逻辑无关的）,一个不稳定的组件应该是具体的（逻辑相关的）
  - 为降低组件之间的耦合度，我们要针对抽象组件编程，而不是针对业务实现编程
- **避免冗余状态**
  - 如果一个数据可由另一个 state 变换得到，那么这个数据就不是一个 state，只需写一个变换的处理函数，在 Vue 中可以使用计算属性
  - 如果一个数据是固定的，不会变化的常量，那么这个数据就如同 HTML 固定的站点标题一样，写死或作为全局配置属性等，不属于 state
  - 如果兄弟组件拥有相同的 state，那么这个 state 应该放到更高的层级，使用 props 传递到两个组件中
- 合理的依赖关系: 父组件不依赖子组件，删除某个子组件不会造成功能异常
- **扁平化参数**: 除了数据，避免复杂的对象，尽量只接收原始类型的值
- **良好的接口设计**: 保证组件的属性和事件足够的给大多数的组件使用。
- API 尽量和已知概念保持一致

**组件设计的边界**

- 页面层级不宜嵌套超过三层，切勿过度设计。
- 这个组件可否（有必要）再分？太小会提升维护成本，太大又不够灵活和高复用性。性能是否会受影响。
- 这个组件的依赖是否可再缩减？缩减组件依赖可以提高组件的可复用度
- 这个组件是否对其它组件造成侵入？
- 这个组件可否复用于其它类似场景中？需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容
- 这个组件当别人用时，会怎么想？接口设计符合规范和大众习惯
- 假如业务需要不需要这个功能，是否方便清除？

## 4. 组件二次封装原则(以 vue 为例)

- _主要以父组件传递数据给子组件来实现一些功能，子组件定义固定的展示样式，将具体要实现的业务逻辑抛出来给父组件处理_
  - 不要在一个 vue 文件内，封装多个数据的入口处理，你应该遵守“单一职责”
  - 如果一个组件要耦合多个数据入口时，把这个组件改造为纯展示组件，跟业务解耦，把业务请求交给父组件。
- _尽量保持 element-ui 组件原有的方法_（可以使用 `v-bind="$attrs"` 和 `v-on="$listeners"`）
- **`$listeners` 对象在 Vue 3 中已被移除。事件监听器现在是 `$attrs` 的一部分.**(参看[透传 Attributes](https://cn.vuejs.org/guide/components/attrs.html))
  - 它们可以使得封装后的组件， “继承”原组件的几乎所有 v-bind 属性和 v-on 事件，且用法和作用与在原组件一样。
  - 如果确实要做更改组件原本的方法，也尽量让相似的方法方法名不变
  - _必须暴露组件的所有 props、事件、插槽和方法_
    - **1）绑定`$attrs` 暴露 props**。实现思路：用计算属性获取`this.$attrs`的值，然后用 `v-bind` 绑定
    - **2）绑定`$listeners` 暴露事件**:`v-on="$listeners"`。
      - 如果你手动写了`v-on="$listeners"`，然后你又自己重写了其中的事件，那么这个事件就会执行两次。
      - 解决方法: 去掉重新的事件，使用 `new$listeners` 继承原有属性，并覆盖原有事件
    - **3）绑定 slots 和 scopedSlots 暴露插槽**:插槽也是必须要暴露给父组件的，主要靠 Vue 提供的 slots 和 scopedSlots。
    - **4）暴露实例的方法**:二次封装的组件暴露出实例，利用实例再调用 element 内部的方法
- 搞清楚哪些是 props，不要修改 props 的数据
- 载体分离原则: 内容和载体要分两个 vue 文件，内容是页面的主要内容，载体是展示的方式，例如弹窗、抽屉等等。

## 5. code review

简单的示例: 代码提交之后，专人负责 review 代码，也可以使用工具设置指定规范性的检查。如果通过了，触发 CI、自动测试等，在合并到指定分支进行构建部署等自动化操作。未通过就修改代码。

code review 的目的:

- **发现错误**: 人都会不可避免的出现一些纰漏，而这些纰漏在另一个人眼中也许显而易见。
- **健壮性检查**: 代码是否健壮，是否有潜在安全、性能风险。代码是否可以回滚。
- **质量保证**: 在一般情况下，新提交的代码一定需要写测试，测试不只可以保证你的提交符合预期，还可以在后人改你的代码时有一层保障。同时，MR(merge request) 阶段也有机器人自动检查当前分支的测试覆盖率是否低于主分支，当低于主分支时会标红警示，但不会禁止 merge。
- **统一风格**: 对于整个团队来说，代码风格的统一很重要。风格统一除了人 Review，我们也引入了静态代码检查，不符合团队风格的代码，是无法通过 CI 的。
- **完善注释**: 包括 commit message、代码中复杂实现是否有解释性的注释、紧急 hack 是否明确标注等。
- **互相学习**
